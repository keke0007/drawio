# 第十七节：生成器和迭代器

讲师：肖斌

## 一、迭代器

**本质：** 一个实现了__iter__方法和__next__方法的对象

**注意 `Iterator`对象和 `Iterable`对象，一个是迭代器，一个是可迭代对象**

1、list、dict、str、tuple、set是可迭代对象但不是迭代器；

2、可迭代对象可以转为迭代器，for循环会自动转换成迭代器。或者调用iter函数

3、如果把所有数据丢到列表中  可以 优点 速度快 缺点 列表占内存太大,如果使用迭代器申请固定的空间也就是一个个的拿出来， 能节约内存，但是浪费时间；

4、需要用类来写迭代器，需要重写 _ _iter_ _( ) 和 _ _next_ _( ）方法；**思考一下**

5、自定义迭代器最大的特点是，需要用类来写，显得代码冗长，不太方便。**所以直接使用生成器**

```python
from collections.abc import Iterable, Iterator
class GenreratorPrime(object):

    def __init__(self):
        self.i = 2

	# 需要用类来写迭代器，需要重写 _ _iter_ _( ) 和 _ _next_ _( ）方法；
    def __iter__(self):
        return self

    def __next__(self):
        if self.i == 2:
            self.i += 1
            return 2

        while True:
            self.i += 1
            for j in range(2, self.i):
                if self.i % j == 0:
                    break
            else:
                return self.i

gp = GenreratorPrime()
print(isinstance(gp, Iterable))
print(isinstance(gp, Iterator))
iter1 = iter(gp)
print(next(iter1))
print(next(iter1))
print(next(iter1))
print(next(iter1))
print(next(iter1))
print(next(iter1))
print(next(iter1))
print(next(iter1))
```


## 二、生成器

生成器（generator）也是一种迭代器 ，在每次迭代时返回一个值，直到抛出 StopIteration 异常。它有两种构造方式：

* 表达式来创建生成器
* 包含有yield的函数来创建生成器

### 1、表达式创建生成器

```python
print([x for x in range(6)])
print((x for x in range(6)))
numbers = (x for x in range(6))
# for n in numbers:
#     print(n)

print(hasattr(numbers, '__iter__'))
print(hasattr(numbers, 'next'))
print(hasattr(numbers, '__next__'))

print(numbers.__next__())

print(next(numbers))
print(next(numbers))
print(next(numbers))
print(next(numbers))
print(next(numbers))
print(next(numbers))
print(next(numbers))
```

**总结：**

**可以看出生成器表达式无法像列表推导式那样直接输出，它和可迭代对象一样只能采用for循环调用next（）函数，原因在于range返回的是一个可迭代对象，列表推导式之所以能直接print就是因为[]将可迭代对象转为列表。**

### 2、含有yield关键字的函数

一个带有 yield 的函数就是一个生成器函数，当我们使用 yield 时，它帮我们自动创建了__iter__() 和 __next__() 方法，而且在没有数据时，也会抛出 StopIteration 异常，也就是我们不费吹灰之力就获得了一个迭代器，非常简洁和高效。

```python
def generator_func():
    v1 = yield 1
    print(f'hello {v1}')
    v1 = yield 2
    print(f'value1 is {v1}')
    v2 = yield 3
    print(f'value2 is {v2}')
    v3 = yield 4
    print(f'value3 is {v3}')


g = generator_func()
print(g.__next__())
print(g.__next__())
print(g.send(100))
g.send(1)
print(g.send(2))
```

**总结：**

1. **yield 把函数变成了一个生成器。**
2. **调用该函数的时候不会立即执行代码，而是返回了一个生成器对象**
3. **当使用 next() (在 for 循环中会自动调用 next() ) 作用于返回的生成器对象时，函数 开始执行，在遇到 yield 的时候会『暂停』，并返回当前的迭代值；**
4. **当再次使用 next() 的时候，函数会从原来『暂停』的地方继续执行，直到遇到 yield语 句，如果没有 yield 语句，则抛出异常；**
5. **生成器函数的执行过程看起来就是不断地 =执行->中断->执行->中断的过程**
6. **send() 方法就是 next() 的功能，加上传值给 上次暂停的yield 。**
7. **close() 方法来关闭一个生成器。生成器被关闭后，再次调用 next() 方法，不管能否遇到 yield 关键字，都会抛出 StopIteration 异常，**

### 3、案例

创建一个获取所有质数的生成器

```python
def generator_prime():
    i = 2
    yield i
    while True:
        i += 1
        for j in range(2, i):
            if i % j == 0:
                break
        else:
            yield i


g = generator_prime()
print(next(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))
```
